<!DOCTYPE html>
<html>
  <head>
    <title>Functors, Monads and Applicative Functors</title>
    <meta charset="utf-8">
        <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-slide-content:after {  
        content: "";
        position: absolute;
        top: 10px;
        right: 100px;
        height: 40px;
        width: 120px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url('data:image/gif;base64,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');
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# More Functional

## Part 2
### Functors, Monads and Applicative Functors

---

# Agenda

1. Options Recap

2. `.map` and `.flatMap`

3. Implementing a Simple Option

4. Functors in Detail

5. Monads in Detail

6. Applicative Functors

7. Monad Patterns

8. The Free Monad
---

# Options Recap

```scala
case class Address(street: String, city: String, state: String, zipCode: String)
case class Person(first: String, last: String, address: Option[Address])

def zipForPerson(op: Option[Person]): Option[String] =
  for {
    p <- op
    a <- p.address
  } yield a.zipCode

val people = List(
  Some(Person("Fred", "Bloggs", None)),
  Some(Person("Simon", "Jones",
    Some(Address("123 Main", "Fakesville", "AZ", "12345")))),
  None
)

people.map(zipForPerson)   // List(None, Some(12345), None)

people(0).flatMap(_.address).map(_.zipCode)  // None
people(1).flatMap(_.address).map(_.zipCode)  // Some(12345)
people(2).flatMap(_.address).map(_.zipCode)  // None
```

---

# Implementing a Simple Optional

```scala
sealed abstract class Optional[+T] {
  def isDefined: Boolean
  def map[U](fn: T => U): Optional[U]		         // Functor
  def flatMap[U](fn: T => Optional[U]): Optional[U]  // Monad* (also apply)
}

case object Nada extends Optional[Nothing] {
  val isDefined: Boolean = ???
  def map[U](fn: Nothing => U): Optional[U] = ???
  def flatMap[U](fn: Nothing => Optional[U]): Optional[U] = ???
}

case class Item[+T](value: T) extends Optional[T] {
  val isDefined: Boolean = ???
  def map[U](fn: T => U): Optional[U] = ???
  def flatMap[U](fn: T => Optional[U]): Optional[U] = ???
}
```

Our old friend, the ADT

This is less complete than, but similar to, the implementation of Option in the Scala standard library

---

# A Functor

```scala
sealed abstract class Optional[+T] {
  def isDefined: Boolean
  def map[U](fn: T => U): Optional[U]		         // Functor
  def flatMap[U](fn: T => Optional[U]): Optional[U]  // Monad* (also apply)
}

case object Nada extends Optional[Nothing] {
  val isDefined: Boolean = false
  def map[U](fn: Nothing => U): Optional[U] = Nada
  def flatMap[U](fn: Nothing => Optional[U]): Optional[U] = ???
}

case class Item[+T](value: T) extends Optional[T] {
  val isDefined: Boolean = true
  def map[U](fn: T => U): Optional[U] = Item(fn(value))
  def flatMap[U](fn: T => Optional[U]): Optional[U] = ???
}
```

---

# A Monad

```scala
sealed abstract class Optional[+T] {
  def isDefined: Boolean
  def map[U](fn: T => U): Optional[U]		         // Functor
  def flatMap[U](fn: T => Optional[U]): Optional[U]  // Monad* (also apply)
}

case object Nada extends Optional[Nothing] {
  val isDefined: Boolean = false
  def map[U](fn: Nothing => U): Optional[U] = Nada
  def flatMap[U](fn: Nothing => Optional[U]): Optional[U] = Nada
}

case class Item[+T](value: T) extends Optional[T] {
  val isDefined: Boolean = true
  def map[U](fn: T => U): Optional[U] = Item(fn(value))
  def flatMap[U](fn: T => Optional[U]): Optional[U] = fn(value)
}
```

---

# Optional In Use

```scala
case class Address(street: String, city: String, state: String, zipCode: String)
case class Person(first: String, last: String, address: Optional[Address])

def zipForPerson(op: Optional[Person]): Optional[String] =
  for {
    p <- op
    a <- p.address
  } yield a.zipCode

val people = List(
  Item(Person("Fred", "Bloggs", Nada)),
  Item(Person("Simon", "Jones",
    Item(Address("123 Main", "Fakesville", "AZ", "12345")))),
  Nada
)

people.map(zipForPerson)  // List(Nada, Item(12345), Nada)
```

---

# Adding a withFilter for Guards

Nothing to do with Monads or Functors, but adding a `withFilter` method allows guards to work in for expressions:

```scala
sealed abstract class Optional[+T] {
  def isDefined: Boolean
  def map[U](fn: T => U): Optional[U]		         // Functor
  def flatMap[U](fn: T => Optional[U]): Optional[U]  // Monad* (also apply)
  def withFilter(p: T => Boolean): Optional[T]       // For guards
}

case object Nada extends Optional[Nothing] {
  val isDefined: Boolean = false
  def map[U](fn: Nothing => U): Optional[U] = Nada
  def flatMap[U](fn: Nothing => Optional[U]): Optional[U] = Nada
  def withFilter(p: Nothing => Boolean): Optional[Nothing] = Nada
}

case class Item[+T](value: T) extends Optional[T] {
  val isDefined: Boolean = true
  def map[U](fn: T => U): Optional[U] = Item(fn(value))
  def flatMap[U](fn: T => Optional[U]): Optional[U] = fn(value)
  def withFilter(p: T => Boolean): Optional[T] =
    if (p(value)) this else Nada
}

```

---

# Testing Our Guard

```scala
case class Address(street: String, city: String, state: String, zipCode: String)
case class Person(first: String, last: String, address: Optional[Address])

def zipForPerson(startsWith: String)(op: Optional[Person]) =
  for {
    p <- op
    if p.first.startsWith(startsWith)
    a <- p.address
  } yield a.zipCode

val people = List(
  Item(Person("Fred", "Bloggs", Nada)),
  Item(Person("Simon", "Jones",
    Item(Address("123 Main", "Fakesville", "AZ", "12345")))),
  Nada
)

people.map(zipForPerson("S"))  // List(Nada, Item(12345), Nada)
people.map(zipForPerson("D"))  // List(Nada, Nada, Nada)

```

---

# Functors

* `.map[T, U](fn: T => U)(M[T]): M[U]`



* Usually implemented as a map on the class itself in Scala



* `x map id                        =          x // Identity`
  * i.e. if you map the id function over a functor, you should get back what you started with

  ```scala
  Item(10).map(identity) == Item(10)
  Nada.map(identity) == Nada
  ```

  

* `x map (a andThen b)    =  (x map a) map b // Composition`

  * i.e. if you map the composition of two functions you should get back the same results as if you mapped the first function, then the second

  ```scala
  Item(10).map(x => x * 2 + 3) == Item(10).map(_ * 2).map(_ + 3)
  Nada.map(x => x * 2 + 3) == Nada.map(_ * 2).map(_ + 3)
  ```

   

---

# Monads

* `.flatMap[T, U](fn: T => M[U])(M[T]): M[U]`



* `apply(x) flatMap f                    = f(x)   // left identity`
  * i.e putting x in a monad and flatmapping f results in same as f(x).

```scala
      Item(5).flatMap (x => Item(x * 2)) == Item(10)
```





* `apply(x) flatMap apply             = apply(x)   // right identity`
  * i.e. putting x in a monad, then flatmapping apply results in the same as just applying it directly.

```scala
      Item(5).flatMap(Item.apply) == Item(5)
```





* `(apply(x) flatMap f) flatMap g = apply(x) flatMap(x => f(x) flatMap g) // associativity`
  * i.e. putting x in a monad then flatmapping f then g results in the same as putting x in a monad, then flatmapping x => f(x) flatMap g

```scala
    (Item(5).flatMap (x => Item(x*2))).flatMap (y => Item(y+3))
      == Item(5).flatMap (x => Item(x*2).flatMap (y => Item(y+3)))

```

---

# Applicative Functors

In our first Option example:

```scala
def zipForPerson(op: Option[Person]): Option[String] =
  for { p <- op; a <- p.address } yield a.zipCode
```

Resolution of `p.address` relies on resolution of `p` from `op` first, but for

```scala
val o1: Option[Int] = Some(1)
val o2: Option[Int] = Some(2)
val o3: Option[Int] = None

def addOptionalInts(oa: Option[Int], ob: Option[Int]): Option[Int] =
  for {
    a <- oa
    b <- ob
  } yield a + b

addOptionalInts(o1, o2)  // Some(3)
addOptionalInts(o2, o3)  // None
```

The options are independent, no ordering is required

---

# Applicative Functor

An Applicative Functor combines the results from containers into a single container of the same type

e.g. a `zip` implementation for Option:

```scala
object Options {
   def zip[A, B](o1: Option[A], o2: Option[B]): Option[(A, B)] = 
    (o1, o2) match {
      case (Some(a), Some(b)) => Some(a, b)
      case _ => None
    }
}

Options.zip(o1, o2)  // Some((1, 2))
Options.zip(o2, o3)  // None
```

---

# What about with a function?

```scala
  def zipWith[A, B, R](o1: Option[A], o2: Option[B])(fn: (A, B) => R): Option[R] =
    zip(o1, o2) match {
      case Some((a, b)) => Some(fn(a, b))
      case _ => None
    }

Options.zipWith(o1, o2)(_ + _)  // Some 3
Options.zipWith(o2, o3)(_ + _)  // None
```

* This is known as an applicative functor



* They have various uses, from simple container aware function mappings like this through to uses like validators (show all failures rather than just the first)

---

# Cartesian Syntax and Alternatives


Libraries like ScalaZ and Cats provide applicative functors with cartesian syntax:

```scala
(o1 |@| o2).map(_ + _)     // Some(3)
(o2 |@| o3).map(_ + _)     // None
```

However, Cats has recently deprecated this for the nicer and more readable:

```scala
(o1, o2).mapN(_ + _)       // Some(3)
(o2, o3).mapN(_ + _)       // None
```

And this works for any conforming cats Functor (+ add your own)

```scala
val f1 = Future(1)
val f2 = Future(2)

val f3 = (f1, f2).mapN(_ + _) // Future[Int]
Await.result(f3, 1.second)    // 3
```

---

# Functor/Monad Patterns

* IO



* Reader



* Writer



* State



* Free

---

# IO

Used to isolate Input/Output effects in a functional way. Remains purely functional until the effect is run:

```scala
val program = IO {
  println("Well, hello, who are you?")
  val name = StdIn.readLine()
  println(s"Well hello, $name, how old are you?")
  val age = StdIn.readLine().trim.toInt
  println(s"Hi $name, I remember being $age, it was grand...")
}

program.unsafeRunSync()

Well, hello, who are you?
Dick
Well hello, Dick, how old are you?
21
Hi Dick, I remember being 21, it was grand...
```

---

# Composing IO

And it composes...

```scala
val p1 = IO {
  println("Name?")
  StdIn.readLine()
}

val p2 = IO {
  println("Age?")
  StdIn.readLine().trim.toInt
}

case class Person(name: String, age: Int)

val p3 = for {
  name <- p1
  age <- p2
} yield Person(name, age)

p3.unsafeRunSync()

// When run, produces output of Person(name, age)
```

---

# Reader

Used to pass defer function application until dependencies are available, another option for dependency injection (with caveats...)

```scala
case class User(name: String, sessionId: String)

case class DBConn(name: String) {
  def getUser(id: Int): User = User("Dick", "1234")
  def putUser(user: User): Unit = println(s"Updating $user")
}

object UserList {
  def updateUser(id: Int, newName: String) =
    Reader { (db: DBConn) =>
      val user = db.getUser(123)
      val altered = user.copy(name = newName)
      db.putUser(altered)
    }
}

val updateU = UserList.updateUser(123, "Ricardo")

updateU.run(DBConn("mydb"))
```

---

# Writer

Carries an accumulating writer or logger along to track or log work done, follow provenance, etc.

```scala
import cats.data.Writer

def authorized(name: String) =
  Writer(List("Verifying user"), name.length >= 3)

def greet(name: String, loggedIn: Boolean) =
  Writer(List("Greet user by name"), {
    val userName = if(loggedIn) name else "User"
    s"Hello $userName"
  })

import cats.instances.list._
val name = "Dick"

val result: Writer[List[String], String] = for {
  loggedIn <- authorized(name)
  greeting <- greet(name, loggedIn)
} yield greeting

result.run
// (List(Verifying user, Greet user by name),Hello Dick)
```

---

# State

Carries some world state along that is passed between uses (state without mutability)

```scala
val take = State[Queue[Int], Int] {
  case Queue()      => sys.error("queue is empty")
  case q            => (q.init, q.last)
}

def put(a: Int) = State[Queue[Int], Unit] { q =>
  (a +: q, ())
}

def useQueue: State[Queue[Int], (Int, Int)] = for {
  _ <- put(3)
  a <- take
  b <- take
} yield (a, b)

useQueue.run(Queue(5, 8, 2, 1)).value
// (Queue(3, 5, 8),(1,2))
```

---

# Free

* The grand-poombah of Functor/Monad patterns



* Create an ADT holding your desired operations



* Use the Free monad to combine them into effectively a "List" of stuff to do



* Once composed, an interpreter is handed the list of work to do



* The interpreter can be swapped out to do different things, making this a very powerful abstraction

---

# Free

Our ADT (and convenient methods to create the operations)

```scala
sealed trait DBFree[A]
case class Save[T](id: Int, value: T) extends DBFree[Unit]
case class Load[T](id: Int) extends DBFree[Option[T]]
case class Remove(id: Int) extends DBFree[Boolean]
case object ShowState extends DBFree[Unit]

type DB[A] = Free[DBFree, A]

import cats.free.Free.liftF // lifters, optional but make life easier

def save[T](id: Int, value: T): DB[Unit] =
  liftF[DBFree, Unit](Save[T](id, value))

def load[T](id: Int): DB[Option[T]] =
  liftF[DBFree, Option[T]](Load[T](id))

def delete(id: Int): DB[Boolean] =
  liftF[DBFree, Boolean](Remove(id))

def showState(): DB[Unit] =
  liftF[DBFree, Unit](ShowState)
```

---

# Free

Add a composite operation

```scala
def modify[T](id: Int, fn: T => T): DB[Unit] =
  for {
    vOpt       <- load[T](id)
    updatedOpt =  vOpt.map(v => fn(v))
    _          <- updatedOpt.
                    map(updated => save[T](id, updated)).
                    getOrElse(Free.pure(()))
  } yield ()
```

And a class to work on

```scala
case class Person(name: String, age: Int)
```



---

# Free

Then write a whole program

```scala
def program: DB[Option[Person]] =
  for {
    _ <- showState()
    _ <- save(123, Person("Dick", 21))
    _ <- showState()
    _ <- modify[Person](123, _.copy(age = 22))
    _ <- showState()
    _ <- save(124, Person("Joan", 22))
    _ <- showState()
    p <- load[Person](123)
    _ <- delete(124)
    _ <- showState()
  } yield p
```



---

# Free

At this stage we have the Free constructed, but not run. Interpreter next:

```scala
def interpreter: DBFree ~> Id  = new (DBFree ~> Id) {
  // ~> is a convenient type to generically promote DBFree ~> Id into 
  // DBFree[T] ~> Id[T] without some of the mess that comes along with it.  
  val fakeDB = mutable.Map.empty[Int, Any]
    
  def apply[A](fa: DBFree[A]): Id[A] =
    fa match {
      case Save(id, value) =>
        fakeDB(id) = value
        ()
      case Load(id) =>
        fakeDB.get(id).flatMap(x => Try(x.asInstanceOf[A]).toOption)
      case Remove(id) =>
        fakeDB.remove(id).isDefined
      case ShowState =>
        println("State now ----------------")
        println(fakeDB)
        ()
    }
  }
```



---

# Free

Finally we can run it and see the results:

```scala
val result: Option[Person] = program.foldMap(interpreter)
// Option[Person] = Some(Person(Dick,22))
```

Output:

```
State now ----------------
Map()
State now ----------------
Map(123 -> Person(Dick,21))
State now ----------------
Map(123 -> Person(Dick,22))
State now ----------------
Map(124 -> Person(Joan,22), 123 -> Person(Dick,22))
State now ----------------
Map(123 -> Person(Dick,22))

```

---

# Dick's Final Rule of Functional Programming

Not everything has to be a Free type! (Principle of Least Power)






    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'scala',
        highlightStyle: 'solarized-light'
      });
    </script>


  </body>
</html>
