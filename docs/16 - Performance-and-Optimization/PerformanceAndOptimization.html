<!DOCTYPE html>
<html>
  <head>
    <title>Performance and Optimization</title>
    <meta charset="utf-8">
        <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      img {
        max-width: 100%;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-slide-content:after {  
        content: "";
        position: absolute;
        top: 10px;
        right: 100px;
        height: 40px;
        width: 120px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url('data:image/gif;base64,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');
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Performance and Optimization

### What Is and Isn't Fast in Scala, and When it Matters

---

# Agenda

1. When and Where to Optimize

2. Collections

3. While Loops and Tail Calls

4. JVM Computation Tips

5. Primitives and Arrays

6. Performance Testing

7. Profiling

8. Caching



---

# When and Where to Optimize

* Write your code first for correctness and readability:
  1. It must work
  2. It must be simple
  3. It can be fast, clever, elegant, etc. but only after 1 and 2





* More than 95% of your potential optimization is in less than 5% of your code




* Find the hotspots, prove the problem, and fix it




* When the 5% of code with the 95% resource usage is no longer in your code, you are either:
  * Done
  * In need of new, better libraries

---

# First Things First

Benchmarks!

And the perils of benchmarks...

```scala
def timeIt[A](name: String)(fn: => A): A = {
  val startTime = System.currentTimeMillis()
  val result = fn
  val elapsed = System.currentTimeMillis() - startTime
  println(s"$name took $elapsed ms")
  result
}
```

* Be aware that hotspot results can vary, never base the decision about an optimization on a single run through the code, make a few separate runs to verify and watch all the results.

---

# Collections

Often the lowest hanging fruit of all:

```scala
def fibs1(limit: Int): List[Long] = {
  (0 to limit).foldLeft(List.empty[Long]) { (acc, i) =>
    if (i < 2) acc :+ i.toLong
    else acc :+ acc.takeRight(2).sum
  }
}

timeIt("list append") {
  fibs1(20000)
}

// list append took 2299 ms
```

* This code is doing List operations at the tail, rather than the head (`:+`)

---

# Vector vs List

One simple fix, if not working exclusively with head operations, is to just substitute a Vector:

```scala
def fibs2(limit: Int): Vector[Long] = {
  (0 to limit).foldLeft(Vector.empty[Long]) { (acc, i) =>
    if (i < 2) acc :+ i.toLong
    else acc :+ acc.takeRight(2).sum
  }
}

timeIt("vector append") {
  fibs2(20000)
}

// vector append took 5 ms
```

so, 2299 ms down to 5 ms, that's **460 times faster!**

---

# Working Only at the Head of the List?

How about if we keep the list but just work exclusively at the head?

```scala
def fibs3(limit: Int): List[Long] = {
  (0 to limit).foldLeft(List.empty[Long]) { (acc, i) =>
    if (i < 2) i :: acc else acc.take(2).sum :: acc
  }.reverse
}

timeIt("list prepend") {
  fibs3(20000)
}

// list prepend took 11 ms
```

Still fast, but slower than vector. That `.reverse` at the end is hurting us. If we don't mind changing the order we can get:

```scala
// list prepend took 4 ms
```

So we can eek out a tiny improvement over Vector, but unless you are working at the head strictly, Vector is usually a better bet.

---

# Arrays

```scala
def fibs4(limit: Int): Array[Long] = {
  val arr = new Array[Long](limit + 1)
  arr(0) = 0
  var (x, a, b) = (0, 0, 1)
  while (x < limit) {
    x += 1
    val temp = a + b
    b = a
    a = temp
    arr(x) = a
  }
  arr
}

timeIt("array") {
  fibs4(100000)  // 5 times as many results
} // array took 2 ms
```

A further order-of-magnitude increase, but at what cost? **Don't** go replacing all of your code with while loops and arrays, the cost is too high...

---

# Arrays are Fast, What Else?

* Register based arithmetic:

```scala
timeIt("math.pow(x, 2)") {
  var outer = 0
  while (outer < 1000000) {
    var x = 0
    while (x < 200000) {
      val y = math.pow(x, 2)
      x += 1
    }
    outer += 1
  }
} // vs
timeIt("x * x") {
  var outer = 0
  while (outer < 1000000) {
    var x = 0
    while (x < 200000) {
      val y = x * x
      x += 1
    }
    outer += 1
  }
}
```

---

# Timing a Few Runs:

```
math.pow(x, 2) took 42 ms
x * x          took 6 ms
math.pow(x, 2) took 14 ms
x * x          took 12 ms
math.pow(x, 2) took 27 ms
x * x          took 3 ms
```

* `x * x` is consistently faster



* `math.pow` depends heavily on hotspot optimizations - sometimes they fire, other times not



* Remember to do multiple timings before drawing conclusions

---

# Bit-wise, When You Can Use Them

```scala
timeIt("x * 2") {
  var outer = 0
  while (outer < 5000000) {
    var x = 0
    while (x < 2000000) {
      val y = x * 2
      x += 1
    }
    outer += 1
  }
}   // 73 ms (sometimes, and sometimes 8ms)

timeIt("x << 1") {
  var outer = 0
  while (outer < 5000000) {
    var x = 0
    while (x < 2000000) {
      val y = x << 1
      x += 1
    }
    outer += 1
  }
}    // 8 ms
```

---

# While/Tail Calls vs for?

You can shave cycles with judicious use of `@tailrec` or `while` instead of `for`:

```scala
var sum: Int = 0

timeIt("random mean with for") {
  for (i <- 0 to 100000000) {
    sum = sum + (if ((i & 1) == 0) i else -i)
  }
}
// random mean with for took 341 ms
```

vs

```scala
sum = 0
timeIt("random mean with while") {
  var i = 0

  while (i < 100000000) {
    sum = sum + (if ((i & 1) == 0) i else -i)
    i += 1
  }
}
// random mean with while took 58 ms
```

---

# While vs TailRec?

Can't always use tailrec, but when you can it gives approximately equivalent performance:

```scala
@tailrec
def randomMean(limit: Int, ct: Int = 0, sum: Int = 0): Double = {
  if (ct >= limit) sum else randomMean(limit, ct + 1,
    sum + (if ((ct & 1) == 0) ct else -ct))
}

timeIt("random mean with tailrec") {
  randomMean(100000000)
}

// random mean with tailrec took 67 ms
```

A tiny bit slower, but given the lack of vars, a few microseconds is usually a good trade for the improved style and safety.

Note the use of `(ct & 1) == 0` as an alternative to `ct % 2 == 0` for even/odd checks.

---

# math.sqrt and Other Library Calls

Like `math.pow(x, 2)`, `math.sqrt(x)` is a slow call, however this time there is no easy arithmetic alternative. There are strategies though:

```scala
case class Coords(x: Double, y: Double)

def withinDistanceOf(compare: Coords, x: Double, y: Double,
    distance: Double): Boolean = {
  val xDelta = compare.x - x
  val yDelta = compare.y - y
  val dist = math.sqrt(xDelta * xDelta + yDelta * yDelta)
  dist <= distance
}

var (countWithinDistance, i, comparisonsCount) = (0, 0, 100000000)

timeIt("Count close items") {
  while (i < comparisonsCount) {
    val x = random.nextDouble() * 10.0
    val y = random.nextDouble() * 10.0
    if (withinDistanceOf(compare, x, y, 2.0)) countWithinDistance += 1
    i += 1
  }
} // Count close items took 1535 ms

```

---

# Avoid the sqrt If You Can

```scala
def withinDistanceOf2(compare: Coords, x: Double, y: Double,
    distance: Double): Boolean = {
  val xDelta = compare.x - x
  val yDelta = compare.y - y
  val distanceSquared = distance * distance // square the compare instead
  (xDelta * xDelta + yDelta * yDelta) <= distanceSquared
}
// Count close items took 1288 ms
```

Other strategies:

* if you actually need the distance value but only if it's within a threshold, use above to filter, then take the square root only of the filtered values (i.e. don't do it if you don't have to)



* If you can, pass the squared distance in to the function to avoid calculating that each time. Document/rename function accordingly to make it obvious

---

# Other Performance Gotchas

* Trigonometric Functions on Java are slower than might be, discussion:
  * http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4857011
  * Avoid them if you can, alternatives, batch calls to native? GPUs? Lookup tables...
  * https://stackoverflow.com/questions/16930581/fast-sine-and-cosine-function-in-java



* Use string interpolation (or StringBuilder)



* Auto-boxing (but use `@specialized` with care to avoid code explosion)



* Pay attention to `equals` and `hashCode` performance (particularly for deep domain objects)



* Let hotspot do its job. Write dumb code: http://www.oracle.com/technetwork/articles/java/devinsight-1-139780.html

---

# Find the Hotspots

The golden rule:

**Do not optimize any code until you have demonstrated that it is the problem!**

1. Use a profiler on running code to find the problems

2. Correct those problems as clearly and readably as possible

3. Repeat until performance is acceptable or you can't find any more improvement

---

# VisualVM

Free performance tool from Oracle

![visualvm](images/visualvm.png)

---

# Using VisualVM

1. Establish a test or main method that runs longer than a few seconds over the code to examine

2. Start visualvm on your computer (and do any setup/performance calibration)

3. Run your test or main method, and attach visualvm when it shows up in the left pane

4. Go to the Sampler tab when ready, and start CPU sampling

5. When ready (after some data has been gathered) take a snapshot and examine it

6. Drill down into the hotspots

7. Refactor code in hotspots, and repeat

8. Stop when the performance is acceptable (spend your effort where it's needed)

---

# Visual VM Demo

![visualvm](images/guru-meditation.jpg)

---

# Caching?

One power tool for performance is caching, but use care. Possibilities:

```scala
lazy val image = HeavyThing.expensivelyComputeImage()
```

But remember it will use memory while someone references the holding object

Also only works for `val`s, can't do lazy `def`s.

You could also check out Cats `Eval` or ScalaZ `memoize` (be careful you understand the trade-offs, thread safety, memory implications, etc.)

For most other purposes, Guava's CacheBuilder is made to order. See Module 1 of this course.





    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'scala',
        highlightStyle: 'solarized-light'
      });
    </script>


  </body>
</html>
